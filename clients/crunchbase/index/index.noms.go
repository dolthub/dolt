// This file was generated by nomdl/codegen.

package main

import (
	"github.com/attic-labs/noms/chunks"
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

var __mainPackageInFile_index_CachedRef ref.Ref

// This function builds up a Noms value that describes the type
// package implemented by this file and registers it with the global
// type package definition cache.
func init() {
	p := types.NewPackage([]types.Type{
		types.MakeEnumType("QuarterEnum", "Q1", "Q2", "Q3", "Q4"),
		types.MakeStructType("Quarter",
			[]types.Field{
				types.Field{"Year", types.MakePrimitiveType(types.Int32Kind), false},
				types.Field{"Quarter", types.MakeType(ref.Ref{}, 0), false},
			},
			types.Choices{},
		),
		types.MakeStructType("Key",
			[]types.Field{},
			types.Choices{
				types.Field{"Category", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Quarter", types.MakeType(ref.Ref{}, 1), false},
				types.Field{"Region", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"RoundType", types.MakeType(ref.Ref{}, 3), false},
				types.Field{"Year", types.MakePrimitiveType(types.Int32Kind), false},
			},
		),
		types.MakeEnumType("RoundTypeEnum", "Seed", "SeriesA", "SeriesB", "SeriesC", "SeriesD", "SeriesE", "SeriesF", "SeriesG", "SeriesH", "UnknownRoundType"),
		types.MakeStructType("RoundRaise",
			[]types.Field{
				types.Field{"Raised", types.MakePrimitiveType(types.Float64Kind), false},
				types.Field{"Details", types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-3e4f60c3fbd518f4a7e903ac1c7c1a97b677c4d9"), 1)), false},
			},
			types.Choices{},
		),
	}, []ref.Ref{
		ref.Parse("sha1-e28aa19ad63c4ddabeb258aafe9b2b97fadd3666"),
		ref.Parse("sha1-3e4f60c3fbd518f4a7e903ac1c7c1a97b677c4d9"),
	})
	__mainPackageInFile_index_CachedRef = types.RegisterPackage(&p)
}

// QuarterEnum

type QuarterEnum uint32

const (
	Q1 QuarterEnum = iota
	Q2
	Q3
	Q4
)

func NewQuarterEnum() QuarterEnum {
	return QuarterEnum(0)
}

var __typeForQuarterEnum types.Type

func (e QuarterEnum) Type() types.Type {
	return __typeForQuarterEnum
}

func init() {
	__typeForQuarterEnum = types.MakeType(__mainPackageInFile_index_CachedRef, 0)
	types.RegisterEnum(__typeForQuarterEnum, builderForQuarterEnum, readerForQuarterEnum)
}

func builderForQuarterEnum(v uint32) types.Value {
	return QuarterEnum(v)
}

func readerForQuarterEnum(v types.Value) uint32 {
	return uint32(v.(QuarterEnum))
}

func (e QuarterEnum) Equals(other types.Value) bool {
	return e == other
}

func (e QuarterEnum) Ref() ref.Ref {
	throwaway := ref.Ref{}
	return types.EnsureRef(&throwaway, e)
}

func (e QuarterEnum) Chunks() []ref.Ref {
	return nil
}

func (e QuarterEnum) ChildValues() []types.Value {
	return nil
}

// Quarter

type Quarter struct {
	_Year    int32
	_Quarter QuarterEnum

	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewQuarter(cs chunks.ChunkStore) Quarter {
	return Quarter{
		_Year:    int32(0),
		_Quarter: NewQuarterEnum(),

		cs:  cs,
		ref: &ref.Ref{},
	}
}

type QuarterDef struct {
	Year    int32
	Quarter QuarterEnum
}

func (def QuarterDef) New(cs chunks.ChunkStore) Quarter {
	return Quarter{
		_Year:    def.Year,
		_Quarter: def.Quarter,
		cs:       cs,
		ref:      &ref.Ref{},
	}
}

func (s Quarter) Def() (d QuarterDef) {
	d.Year = s._Year
	d.Quarter = s._Quarter
	return
}

var __typeForQuarter types.Type

func (m Quarter) Type() types.Type {
	return __typeForQuarter
}

func init() {
	__typeForQuarter = types.MakeType(__mainPackageInFile_index_CachedRef, 1)
	types.RegisterStruct(__typeForQuarter, builderForQuarter, readerForQuarter)
}

func builderForQuarter(cs chunks.ChunkStore, values []types.Value) types.Value {
	i := 0
	s := Quarter{ref: &ref.Ref{}, cs: cs}
	s._Year = int32(values[i].(types.Int32))
	i++
	s._Quarter = values[i].(QuarterEnum)
	i++
	return s
}

func readerForQuarter(v types.Value) []types.Value {
	values := []types.Value{}
	s := v.(Quarter)
	values = append(values, types.Int32(s._Year))
	values = append(values, s._Quarter)
	return values
}

func (s Quarter) Equals(other types.Value) bool {
	return other != nil && __typeForQuarter.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s Quarter) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s Quarter) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, __typeForQuarter.Chunks()...)
	return
}

func (s Quarter) ChildValues() (ret []types.Value) {
	ret = append(ret, types.Int32(s._Year))
	ret = append(ret, s._Quarter)
	return
}

func (s Quarter) Year() int32 {
	return s._Year
}

func (s Quarter) SetYear(val int32) Quarter {
	s._Year = val
	s.ref = &ref.Ref{}
	return s
}

func (s Quarter) Quarter() QuarterEnum {
	return s._Quarter
}

func (s Quarter) SetQuarter(val QuarterEnum) Quarter {
	s._Quarter = val
	s.ref = &ref.Ref{}
	return s
}

// Key

type Key struct {
	__unionIndex uint32
	__unionValue types.Value
	cs           chunks.ChunkStore
	ref          *ref.Ref
}

func NewKey(cs chunks.ChunkStore) Key {
	return Key{
		__unionIndex: 0,
		__unionValue: types.NewString(""),
		cs:           cs,
		ref:          &ref.Ref{},
	}
}

type KeyDef struct {
	__unionIndex uint32
	__unionValue types.Value
}

func (def KeyDef) New(cs chunks.ChunkStore) Key {
	return Key{
		__unionIndex: def.__unionIndex,
		__unionValue: def.__unionValue,
		cs:           cs,
		ref:          &ref.Ref{},
	}
}

func (s Key) Def() (d KeyDef) {
	d.__unionIndex = s.__unionIndex
	d.__unionValue = s.__unionValue
	return
}

var __typeForKey types.Type

func (m Key) Type() types.Type {
	return __typeForKey
}

func init() {
	__typeForKey = types.MakeType(__mainPackageInFile_index_CachedRef, 2)
	types.RegisterStruct(__typeForKey, builderForKey, readerForKey)
}

func builderForKey(cs chunks.ChunkStore, values []types.Value) types.Value {
	i := 0
	s := Key{ref: &ref.Ref{}, cs: cs}
	s.__unionIndex = uint32(values[i].(types.Uint32))
	i++
	s.__unionValue = values[i]
	i++
	return s
}

func readerForKey(v types.Value) []types.Value {
	values := []types.Value{}
	s := v.(Key)
	values = append(values, types.Uint32(s.__unionIndex))
	values = append(values, s.__unionValue)
	return values
}

func (s Key) Equals(other types.Value) bool {
	return other != nil && __typeForKey.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s Key) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s Key) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, __typeForKey.Chunks()...)
	chunks = append(chunks, s.__unionValue.Chunks()...)
	return
}

func (s Key) ChildValues() (ret []types.Value) {
	ret = append(ret, s.__unionValue)
	return
}

func (s Key) Category() (val string, ok bool) {
	if s.__unionIndex != 0 {
		return
	}
	return s.__unionValue.(types.String).String(), true
}

func (s Key) SetCategory(val string) Key {
	s.__unionIndex = 0
	s.__unionValue = types.NewString(val)
	s.ref = &ref.Ref{}
	return s
}

func (def KeyDef) Category() (val string, ok bool) {
	if def.__unionIndex != 0 {
		return
	}
	return def.__unionValue.(types.String).String(), true
}

func (def KeyDef) SetCategory(cs chunks.ChunkStore, val string) KeyDef {
	def.__unionIndex = 0
	def.__unionValue = types.NewString(val)
	return def
}

func (s Key) Quarter() (val Quarter, ok bool) {
	if s.__unionIndex != 1 {
		return
	}
	return s.__unionValue.(Quarter), true
}

func (s Key) SetQuarter(val Quarter) Key {
	s.__unionIndex = 1
	s.__unionValue = val
	s.ref = &ref.Ref{}
	return s
}

func (def KeyDef) Quarter() (val QuarterDef, ok bool) {
	if def.__unionIndex != 1 {
		return
	}
	return def.__unionValue.(Quarter).Def(), true
}

func (def KeyDef) SetQuarter(cs chunks.ChunkStore, val QuarterDef) KeyDef {
	def.__unionIndex = 1
	def.__unionValue = val.New(cs)
	return def
}

func (s Key) Region() (val string, ok bool) {
	if s.__unionIndex != 2 {
		return
	}
	return s.__unionValue.(types.String).String(), true
}

func (s Key) SetRegion(val string) Key {
	s.__unionIndex = 2
	s.__unionValue = types.NewString(val)
	s.ref = &ref.Ref{}
	return s
}

func (def KeyDef) Region() (val string, ok bool) {
	if def.__unionIndex != 2 {
		return
	}
	return def.__unionValue.(types.String).String(), true
}

func (def KeyDef) SetRegion(cs chunks.ChunkStore, val string) KeyDef {
	def.__unionIndex = 2
	def.__unionValue = types.NewString(val)
	return def
}

func (s Key) RoundType() (val RoundTypeEnum, ok bool) {
	if s.__unionIndex != 3 {
		return
	}
	return s.__unionValue.(RoundTypeEnum), true
}

func (s Key) SetRoundType(val RoundTypeEnum) Key {
	s.__unionIndex = 3
	s.__unionValue = val
	s.ref = &ref.Ref{}
	return s
}

func (def KeyDef) RoundType() (val RoundTypeEnum, ok bool) {
	if def.__unionIndex != 3 {
		return
	}
	return def.__unionValue.(RoundTypeEnum), true
}

func (def KeyDef) SetRoundType(cs chunks.ChunkStore, val RoundTypeEnum) KeyDef {
	def.__unionIndex = 3
	def.__unionValue = val
	return def
}

func (s Key) Year() (val int32, ok bool) {
	if s.__unionIndex != 4 {
		return
	}
	return int32(s.__unionValue.(types.Int32)), true
}

func (s Key) SetYear(val int32) Key {
	s.__unionIndex = 4
	s.__unionValue = types.Int32(val)
	s.ref = &ref.Ref{}
	return s
}

func (def KeyDef) Year() (val int32, ok bool) {
	if def.__unionIndex != 4 {
		return
	}
	return int32(def.__unionValue.(types.Int32)), true
}

func (def KeyDef) SetYear(cs chunks.ChunkStore, val int32) KeyDef {
	def.__unionIndex = 4
	def.__unionValue = types.Int32(val)
	return def
}

// RoundTypeEnum

type RoundTypeEnum uint32

const (
	Seed RoundTypeEnum = iota
	SeriesA
	SeriesB
	SeriesC
	SeriesD
	SeriesE
	SeriesF
	SeriesG
	SeriesH
	UnknownRoundType
)

func NewRoundTypeEnum() RoundTypeEnum {
	return RoundTypeEnum(0)
}

var __typeForRoundTypeEnum types.Type

func (e RoundTypeEnum) Type() types.Type {
	return __typeForRoundTypeEnum
}

func init() {
	__typeForRoundTypeEnum = types.MakeType(__mainPackageInFile_index_CachedRef, 3)
	types.RegisterEnum(__typeForRoundTypeEnum, builderForRoundTypeEnum, readerForRoundTypeEnum)
}

func builderForRoundTypeEnum(v uint32) types.Value {
	return RoundTypeEnum(v)
}

func readerForRoundTypeEnum(v types.Value) uint32 {
	return uint32(v.(RoundTypeEnum))
}

func (e RoundTypeEnum) Equals(other types.Value) bool {
	return e == other
}

func (e RoundTypeEnum) Ref() ref.Ref {
	throwaway := ref.Ref{}
	return types.EnsureRef(&throwaway, e)
}

func (e RoundTypeEnum) Chunks() []ref.Ref {
	return nil
}

func (e RoundTypeEnum) ChildValues() []types.Value {
	return nil
}

// RoundRaise

type RoundRaise struct {
	_Raised  float64
	_Details RefOfRound

	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewRoundRaise(cs chunks.ChunkStore) RoundRaise {
	return RoundRaise{
		_Raised:  float64(0),
		_Details: NewRefOfRound(ref.Ref{}),

		cs:  cs,
		ref: &ref.Ref{},
	}
}

type RoundRaiseDef struct {
	Raised  float64
	Details ref.Ref
}

func (def RoundRaiseDef) New(cs chunks.ChunkStore) RoundRaise {
	return RoundRaise{
		_Raised:  def.Raised,
		_Details: NewRefOfRound(def.Details),
		cs:       cs,
		ref:      &ref.Ref{},
	}
}

func (s RoundRaise) Def() (d RoundRaiseDef) {
	d.Raised = s._Raised
	d.Details = s._Details.TargetRef()
	return
}

var __typeForRoundRaise types.Type

func (m RoundRaise) Type() types.Type {
	return __typeForRoundRaise
}

func init() {
	__typeForRoundRaise = types.MakeType(__mainPackageInFile_index_CachedRef, 4)
	types.RegisterStruct(__typeForRoundRaise, builderForRoundRaise, readerForRoundRaise)
}

func builderForRoundRaise(cs chunks.ChunkStore, values []types.Value) types.Value {
	i := 0
	s := RoundRaise{ref: &ref.Ref{}, cs: cs}
	s._Raised = float64(values[i].(types.Float64))
	i++
	s._Details = values[i].(RefOfRound)
	i++
	return s
}

func readerForRoundRaise(v types.Value) []types.Value {
	values := []types.Value{}
	s := v.(RoundRaise)
	values = append(values, types.Float64(s._Raised))
	values = append(values, s._Details)
	return values
}

func (s RoundRaise) Equals(other types.Value) bool {
	return other != nil && __typeForRoundRaise.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s RoundRaise) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s RoundRaise) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, __typeForRoundRaise.Chunks()...)
	chunks = append(chunks, s._Details.Chunks()...)
	return
}

func (s RoundRaise) ChildValues() (ret []types.Value) {
	ret = append(ret, types.Float64(s._Raised))
	ret = append(ret, s._Details)
	return
}

func (s RoundRaise) Raised() float64 {
	return s._Raised
}

func (s RoundRaise) SetRaised(val float64) RoundRaise {
	s._Raised = val
	s.ref = &ref.Ref{}
	return s
}

func (s RoundRaise) Details() RefOfRound {
	return s._Details
}

func (s RoundRaise) SetDetails(val RefOfRound) RoundRaise {
	s._Details = val
	s.ref = &ref.Ref{}
	return s
}

// MapOfRefOfKeyToSetOfRoundRaise

type MapOfRefOfKeyToSetOfRoundRaise struct {
	m   types.Map
	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewMapOfRefOfKeyToSetOfRoundRaise(cs chunks.ChunkStore) MapOfRefOfKeyToSetOfRoundRaise {
	return MapOfRefOfKeyToSetOfRoundRaise{types.NewTypedMap(cs, __typeForMapOfRefOfKeyToSetOfRoundRaise), cs, &ref.Ref{}}
}

type MapOfRefOfKeyToSetOfRoundRaiseDef map[ref.Ref]SetOfRoundRaiseDef

func (def MapOfRefOfKeyToSetOfRoundRaiseDef) New(cs chunks.ChunkStore) MapOfRefOfKeyToSetOfRoundRaise {
	kv := make([]types.Value, 0, len(def)*2)
	for k, v := range def {
		kv = append(kv, NewRefOfKey(k), v.New(cs))
	}
	return MapOfRefOfKeyToSetOfRoundRaise{types.NewTypedMap(cs, __typeForMapOfRefOfKeyToSetOfRoundRaise, kv...), cs, &ref.Ref{}}
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Def() MapOfRefOfKeyToSetOfRoundRaiseDef {
	def := make(map[ref.Ref]SetOfRoundRaiseDef)
	m.m.Iter(func(k, v types.Value) bool {
		def[k.(RefOfKey).TargetRef()] = v.(SetOfRoundRaise).Def()
		return false
	})
	return def
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Equals(other types.Value) bool {
	return other != nil && __typeForMapOfRefOfKeyToSetOfRoundRaise.Equals(other.Type()) && m.Ref() == other.Ref()
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Ref() ref.Ref {
	return types.EnsureRef(m.ref, m)
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, m.Type().Chunks()...)
	chunks = append(chunks, m.m.Chunks()...)
	return
}

func (m MapOfRefOfKeyToSetOfRoundRaise) ChildValues() []types.Value {
	return append([]types.Value{}, m.m.ChildValues()...)
}

// A Noms Value that describes MapOfRefOfKeyToSetOfRoundRaise.
var __typeForMapOfRefOfKeyToSetOfRoundRaise types.Type

func (m MapOfRefOfKeyToSetOfRoundRaise) Type() types.Type {
	return __typeForMapOfRefOfKeyToSetOfRoundRaise
}

func init() {
	__typeForMapOfRefOfKeyToSetOfRoundRaise = types.MakeCompoundType(types.MapKind, types.MakeCompoundType(types.RefKind, types.MakeType(__mainPackageInFile_index_CachedRef, 2)), types.MakeCompoundType(types.SetKind, types.MakeType(__mainPackageInFile_index_CachedRef, 4)))
	types.RegisterValue(__typeForMapOfRefOfKeyToSetOfRoundRaise, builderForMapOfRefOfKeyToSetOfRoundRaise, readerForMapOfRefOfKeyToSetOfRoundRaise)
}

func builderForMapOfRefOfKeyToSetOfRoundRaise(cs chunks.ChunkStore, v types.Value) types.Value {
	return MapOfRefOfKeyToSetOfRoundRaise{v.(types.Map), cs, &ref.Ref{}}
}

func readerForMapOfRefOfKeyToSetOfRoundRaise(v types.Value) types.Value {
	return v.(MapOfRefOfKeyToSetOfRoundRaise).m
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Empty() bool {
	return m.m.Empty()
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Len() uint64 {
	return m.m.Len()
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Has(p RefOfKey) bool {
	return m.m.Has(p)
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Get(p RefOfKey) SetOfRoundRaise {
	return m.m.Get(p).(SetOfRoundRaise)
}

func (m MapOfRefOfKeyToSetOfRoundRaise) MaybeGet(p RefOfKey) (SetOfRoundRaise, bool) {
	v, ok := m.m.MaybeGet(p)
	if !ok {
		return NewSetOfRoundRaise(m.cs), false
	}
	return v.(SetOfRoundRaise), ok
}

func (m MapOfRefOfKeyToSetOfRoundRaise) Set(k RefOfKey, v SetOfRoundRaise) MapOfRefOfKeyToSetOfRoundRaise {
	return MapOfRefOfKeyToSetOfRoundRaise{m.m.Set(k, v), m.cs, &ref.Ref{}}
}

// TODO: Implement SetM?

func (m MapOfRefOfKeyToSetOfRoundRaise) Remove(p RefOfKey) MapOfRefOfKeyToSetOfRoundRaise {
	return MapOfRefOfKeyToSetOfRoundRaise{m.m.Remove(p), m.cs, &ref.Ref{}}
}

type MapOfRefOfKeyToSetOfRoundRaiseIterCallback func(k RefOfKey, v SetOfRoundRaise) (stop bool)

func (m MapOfRefOfKeyToSetOfRoundRaise) Iter(cb MapOfRefOfKeyToSetOfRoundRaiseIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(k.(RefOfKey), v.(SetOfRoundRaise))
	})
}

type MapOfRefOfKeyToSetOfRoundRaiseIterAllCallback func(k RefOfKey, v SetOfRoundRaise)

func (m MapOfRefOfKeyToSetOfRoundRaise) IterAll(cb MapOfRefOfKeyToSetOfRoundRaiseIterAllCallback) {
	m.m.IterAll(func(k, v types.Value) {
		cb(k.(RefOfKey), v.(SetOfRoundRaise))
	})
}

func (m MapOfRefOfKeyToSetOfRoundRaise) IterAllP(concurrency int, cb MapOfRefOfKeyToSetOfRoundRaiseIterAllCallback) {
	m.m.IterAllP(concurrency, func(k, v types.Value) {
		cb(k.(RefOfKey), v.(SetOfRoundRaise))
	})
}

type MapOfRefOfKeyToSetOfRoundRaiseFilterCallback func(k RefOfKey, v SetOfRoundRaise) (keep bool)

func (m MapOfRefOfKeyToSetOfRoundRaise) Filter(cb MapOfRefOfKeyToSetOfRoundRaiseFilterCallback) MapOfRefOfKeyToSetOfRoundRaise {
	out := m.m.Filter(func(k, v types.Value) bool {
		return cb(k.(RefOfKey), v.(SetOfRoundRaise))
	})
	return MapOfRefOfKeyToSetOfRoundRaise{out, m.cs, &ref.Ref{}}
}

// MapOfRefOfKeyToRefOfSetOfRoundRaise

type MapOfRefOfKeyToRefOfSetOfRoundRaise struct {
	m   types.Map
	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewMapOfRefOfKeyToRefOfSetOfRoundRaise(cs chunks.ChunkStore) MapOfRefOfKeyToRefOfSetOfRoundRaise {
	return MapOfRefOfKeyToRefOfSetOfRoundRaise{types.NewTypedMap(cs, __typeForMapOfRefOfKeyToRefOfSetOfRoundRaise), cs, &ref.Ref{}}
}

type MapOfRefOfKeyToRefOfSetOfRoundRaiseDef map[ref.Ref]ref.Ref

func (def MapOfRefOfKeyToRefOfSetOfRoundRaiseDef) New(cs chunks.ChunkStore) MapOfRefOfKeyToRefOfSetOfRoundRaise {
	kv := make([]types.Value, 0, len(def)*2)
	for k, v := range def {
		kv = append(kv, NewRefOfKey(k), NewRefOfSetOfRoundRaise(v))
	}
	return MapOfRefOfKeyToRefOfSetOfRoundRaise{types.NewTypedMap(cs, __typeForMapOfRefOfKeyToRefOfSetOfRoundRaise, kv...), cs, &ref.Ref{}}
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Def() MapOfRefOfKeyToRefOfSetOfRoundRaiseDef {
	def := make(map[ref.Ref]ref.Ref)
	m.m.Iter(func(k, v types.Value) bool {
		def[k.(RefOfKey).TargetRef()] = v.(RefOfSetOfRoundRaise).TargetRef()
		return false
	})
	return def
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Equals(other types.Value) bool {
	return other != nil && __typeForMapOfRefOfKeyToRefOfSetOfRoundRaise.Equals(other.Type()) && m.Ref() == other.Ref()
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Ref() ref.Ref {
	return types.EnsureRef(m.ref, m)
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, m.Type().Chunks()...)
	chunks = append(chunks, m.m.Chunks()...)
	return
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) ChildValues() []types.Value {
	return append([]types.Value{}, m.m.ChildValues()...)
}

// A Noms Value that describes MapOfRefOfKeyToRefOfSetOfRoundRaise.
var __typeForMapOfRefOfKeyToRefOfSetOfRoundRaise types.Type

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Type() types.Type {
	return __typeForMapOfRefOfKeyToRefOfSetOfRoundRaise
}

func init() {
	__typeForMapOfRefOfKeyToRefOfSetOfRoundRaise = types.MakeCompoundType(types.MapKind, types.MakeCompoundType(types.RefKind, types.MakeType(__mainPackageInFile_index_CachedRef, 2)), types.MakeCompoundType(types.RefKind, types.MakeCompoundType(types.SetKind, types.MakeType(__mainPackageInFile_index_CachedRef, 4))))
	types.RegisterValue(__typeForMapOfRefOfKeyToRefOfSetOfRoundRaise, builderForMapOfRefOfKeyToRefOfSetOfRoundRaise, readerForMapOfRefOfKeyToRefOfSetOfRoundRaise)
}

func builderForMapOfRefOfKeyToRefOfSetOfRoundRaise(cs chunks.ChunkStore, v types.Value) types.Value {
	return MapOfRefOfKeyToRefOfSetOfRoundRaise{v.(types.Map), cs, &ref.Ref{}}
}

func readerForMapOfRefOfKeyToRefOfSetOfRoundRaise(v types.Value) types.Value {
	return v.(MapOfRefOfKeyToRefOfSetOfRoundRaise).m
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Empty() bool {
	return m.m.Empty()
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Len() uint64 {
	return m.m.Len()
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Has(p RefOfKey) bool {
	return m.m.Has(p)
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Get(p RefOfKey) RefOfSetOfRoundRaise {
	return m.m.Get(p).(RefOfSetOfRoundRaise)
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) MaybeGet(p RefOfKey) (RefOfSetOfRoundRaise, bool) {
	v, ok := m.m.MaybeGet(p)
	if !ok {
		return NewRefOfSetOfRoundRaise(ref.Ref{}), false
	}
	return v.(RefOfSetOfRoundRaise), ok
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Set(k RefOfKey, v RefOfSetOfRoundRaise) MapOfRefOfKeyToRefOfSetOfRoundRaise {
	return MapOfRefOfKeyToRefOfSetOfRoundRaise{m.m.Set(k, v), m.cs, &ref.Ref{}}
}

// TODO: Implement SetM?

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Remove(p RefOfKey) MapOfRefOfKeyToRefOfSetOfRoundRaise {
	return MapOfRefOfKeyToRefOfSetOfRoundRaise{m.m.Remove(p), m.cs, &ref.Ref{}}
}

type MapOfRefOfKeyToRefOfSetOfRoundRaiseIterCallback func(k RefOfKey, v RefOfSetOfRoundRaise) (stop bool)

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Iter(cb MapOfRefOfKeyToRefOfSetOfRoundRaiseIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(k.(RefOfKey), v.(RefOfSetOfRoundRaise))
	})
}

type MapOfRefOfKeyToRefOfSetOfRoundRaiseIterAllCallback func(k RefOfKey, v RefOfSetOfRoundRaise)

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) IterAll(cb MapOfRefOfKeyToRefOfSetOfRoundRaiseIterAllCallback) {
	m.m.IterAll(func(k, v types.Value) {
		cb(k.(RefOfKey), v.(RefOfSetOfRoundRaise))
	})
}

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) IterAllP(concurrency int, cb MapOfRefOfKeyToRefOfSetOfRoundRaiseIterAllCallback) {
	m.m.IterAllP(concurrency, func(k, v types.Value) {
		cb(k.(RefOfKey), v.(RefOfSetOfRoundRaise))
	})
}

type MapOfRefOfKeyToRefOfSetOfRoundRaiseFilterCallback func(k RefOfKey, v RefOfSetOfRoundRaise) (keep bool)

func (m MapOfRefOfKeyToRefOfSetOfRoundRaise) Filter(cb MapOfRefOfKeyToRefOfSetOfRoundRaiseFilterCallback) MapOfRefOfKeyToRefOfSetOfRoundRaise {
	out := m.m.Filter(func(k, v types.Value) bool {
		return cb(k.(RefOfKey), v.(RefOfSetOfRoundRaise))
	})
	return MapOfRefOfKeyToRefOfSetOfRoundRaise{out, m.cs, &ref.Ref{}}
}

// RefOfKey

type RefOfKey struct {
	target ref.Ref
	ref    *ref.Ref
}

func NewRefOfKey(target ref.Ref) RefOfKey {
	return RefOfKey{target, &ref.Ref{}}
}

func (r RefOfKey) TargetRef() ref.Ref {
	return r.target
}

func (r RefOfKey) Ref() ref.Ref {
	return types.EnsureRef(r.ref, r)
}

func (r RefOfKey) Equals(other types.Value) bool {
	return other != nil && __typeForRefOfKey.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r RefOfKey) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r.target)
	return
}

func (r RefOfKey) ChildValues() []types.Value {
	return nil
}

// A Noms Value that describes RefOfKey.
var __typeForRefOfKey types.Type

func (m RefOfKey) Type() types.Type {
	return __typeForRefOfKey
}

func init() {
	__typeForRefOfKey = types.MakeCompoundType(types.RefKind, types.MakeType(__mainPackageInFile_index_CachedRef, 2))
	types.RegisterRef(__typeForRefOfKey, builderForRefOfKey)
}

func builderForRefOfKey(r ref.Ref) types.Value {
	return NewRefOfKey(r)
}

func (r RefOfKey) TargetValue(cs chunks.ChunkStore) Key {
	return types.ReadValue(r.target, cs).(Key)
}

func (r RefOfKey) SetTargetValue(val Key, cs chunks.ChunkSink) RefOfKey {
	return NewRefOfKey(types.WriteValue(val, cs))
}

// SetOfRoundRaise

type SetOfRoundRaise struct {
	s   types.Set
	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewSetOfRoundRaise(cs chunks.ChunkStore) SetOfRoundRaise {
	return SetOfRoundRaise{types.NewTypedSet(cs, __typeForSetOfRoundRaise), cs, &ref.Ref{}}
}

type SetOfRoundRaiseDef map[RoundRaiseDef]bool

func (def SetOfRoundRaiseDef) New(cs chunks.ChunkStore) SetOfRoundRaise {
	l := make([]types.Value, len(def))
	i := 0
	for d, _ := range def {
		l[i] = d.New(cs)
		i++
	}
	return SetOfRoundRaise{types.NewTypedSet(cs, __typeForSetOfRoundRaise, l...), cs, &ref.Ref{}}
}

func (s SetOfRoundRaise) Def() SetOfRoundRaiseDef {
	def := make(map[RoundRaiseDef]bool, s.Len())
	s.s.Iter(func(v types.Value) bool {
		def[v.(RoundRaise).Def()] = true
		return false
	})
	return def
}

func (s SetOfRoundRaise) Equals(other types.Value) bool {
	return other != nil && __typeForSetOfRoundRaise.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s SetOfRoundRaise) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s SetOfRoundRaise) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, s.Type().Chunks()...)
	chunks = append(chunks, s.s.Chunks()...)
	return
}

func (s SetOfRoundRaise) ChildValues() []types.Value {
	return append([]types.Value{}, s.s.ChildValues()...)
}

// A Noms Value that describes SetOfRoundRaise.
var __typeForSetOfRoundRaise types.Type

func (m SetOfRoundRaise) Type() types.Type {
	return __typeForSetOfRoundRaise
}

func init() {
	__typeForSetOfRoundRaise = types.MakeCompoundType(types.SetKind, types.MakeType(__mainPackageInFile_index_CachedRef, 4))
	types.RegisterValue(__typeForSetOfRoundRaise, builderForSetOfRoundRaise, readerForSetOfRoundRaise)
}

func builderForSetOfRoundRaise(cs chunks.ChunkStore, v types.Value) types.Value {
	return SetOfRoundRaise{v.(types.Set), cs, &ref.Ref{}}
}

func readerForSetOfRoundRaise(v types.Value) types.Value {
	return v.(SetOfRoundRaise).s
}

func (s SetOfRoundRaise) Empty() bool {
	return s.s.Empty()
}

func (s SetOfRoundRaise) Len() uint64 {
	return s.s.Len()
}

func (s SetOfRoundRaise) Has(p RoundRaise) bool {
	return s.s.Has(p)
}

type SetOfRoundRaiseIterCallback func(p RoundRaise) (stop bool)

func (s SetOfRoundRaise) Iter(cb SetOfRoundRaiseIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(v.(RoundRaise))
	})
}

type SetOfRoundRaiseIterAllCallback func(p RoundRaise)

func (s SetOfRoundRaise) IterAll(cb SetOfRoundRaiseIterAllCallback) {
	s.s.IterAll(func(v types.Value) {
		cb(v.(RoundRaise))
	})
}

func (s SetOfRoundRaise) IterAllP(concurrency int, cb SetOfRoundRaiseIterAllCallback) {
	s.s.IterAllP(concurrency, func(v types.Value) {
		cb(v.(RoundRaise))
	})
}

type SetOfRoundRaiseFilterCallback func(p RoundRaise) (keep bool)

func (s SetOfRoundRaise) Filter(cb SetOfRoundRaiseFilterCallback) SetOfRoundRaise {
	out := s.s.Filter(func(v types.Value) bool {
		return cb(v.(RoundRaise))
	})
	return SetOfRoundRaise{out, s.cs, &ref.Ref{}}
}

func (s SetOfRoundRaise) Insert(p ...RoundRaise) SetOfRoundRaise {
	return SetOfRoundRaise{s.s.Insert(s.fromElemSlice(p)...), s.cs, &ref.Ref{}}
}

func (s SetOfRoundRaise) Remove(p ...RoundRaise) SetOfRoundRaise {
	return SetOfRoundRaise{s.s.Remove(s.fromElemSlice(p)...), s.cs, &ref.Ref{}}
}

func (s SetOfRoundRaise) Union(others ...SetOfRoundRaise) SetOfRoundRaise {
	return SetOfRoundRaise{s.s.Union(s.fromStructSlice(others)...), s.cs, &ref.Ref{}}
}

func (s SetOfRoundRaise) Subtract(others ...SetOfRoundRaise) SetOfRoundRaise {
	return SetOfRoundRaise{s.s.Subtract(s.fromStructSlice(others)...), s.cs, &ref.Ref{}}
}

func (s SetOfRoundRaise) First() RoundRaise {
	return s.s.First().(RoundRaise)
}

func (s SetOfRoundRaise) fromStructSlice(p []SetOfRoundRaise) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfRoundRaise) fromElemSlice(p []RoundRaise) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}

// RefOfSetOfRoundRaise

type RefOfSetOfRoundRaise struct {
	target ref.Ref
	ref    *ref.Ref
}

func NewRefOfSetOfRoundRaise(target ref.Ref) RefOfSetOfRoundRaise {
	return RefOfSetOfRoundRaise{target, &ref.Ref{}}
}

func (r RefOfSetOfRoundRaise) TargetRef() ref.Ref {
	return r.target
}

func (r RefOfSetOfRoundRaise) Ref() ref.Ref {
	return types.EnsureRef(r.ref, r)
}

func (r RefOfSetOfRoundRaise) Equals(other types.Value) bool {
	return other != nil && __typeForRefOfSetOfRoundRaise.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r RefOfSetOfRoundRaise) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r.target)
	return
}

func (r RefOfSetOfRoundRaise) ChildValues() []types.Value {
	return nil
}

// A Noms Value that describes RefOfSetOfRoundRaise.
var __typeForRefOfSetOfRoundRaise types.Type

func (m RefOfSetOfRoundRaise) Type() types.Type {
	return __typeForRefOfSetOfRoundRaise
}

func init() {
	__typeForRefOfSetOfRoundRaise = types.MakeCompoundType(types.RefKind, types.MakeCompoundType(types.SetKind, types.MakeType(__mainPackageInFile_index_CachedRef, 4)))
	types.RegisterRef(__typeForRefOfSetOfRoundRaise, builderForRefOfSetOfRoundRaise)
}

func builderForRefOfSetOfRoundRaise(r ref.Ref) types.Value {
	return NewRefOfSetOfRoundRaise(r)
}

func (r RefOfSetOfRoundRaise) TargetValue(cs chunks.ChunkStore) SetOfRoundRaise {
	return types.ReadValue(r.target, cs).(SetOfRoundRaise)
}

func (r RefOfSetOfRoundRaise) SetTargetValue(val SetOfRoundRaise, cs chunks.ChunkSink) RefOfSetOfRoundRaise {
	return NewRefOfSetOfRoundRaise(types.WriteValue(val, cs))
}
