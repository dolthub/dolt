// This file was generated by nomgen.
// To regenerate, run `go generate` in this package.

package main

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// User

type User struct {
	m types.Map
}

func NewUser() User {
	return User{types.NewMap()}
}

func UserFromVal(v types.Value) User {
	return User{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s User) NomsValue() types.Map {
	return s.m
}

func (s User) Equals(p User) bool {
	return s.m.Equals(p.m)
}

func (s User) Ref() ref.Ref {
	return s.m.Ref()
}
func (s User) OAuthToken() types.String {
	return s.m.Get(types.NewString("oAuthToken")).(types.String)
}

func (s User) SetOAuthToken(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("oAuthToken"), p))
}
func (s User) Name() types.String {
	return s.m.Get(types.NewString("name")).(types.String)
}

func (s User) SetName(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("name"), p))
}
func (s User) Id() types.String {
	return s.m.Get(types.NewString("id")).(types.String)
}

func (s User) SetId(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("id"), p))
}
func (s User) OAuthSecret() types.String {
	return s.m.Get(types.NewString("oAuthSecret")).(types.String)
}

func (s User) SetOAuthSecret(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("oAuthSecret"), p))
}
func (s User) Photosets() PhotosetSet {
	return PhotosetSetFromVal(s.m.Get(types.NewString("photosets")))
}

func (s User) SetPhotosets(p PhotosetSet) User {
	return UserFromVal(s.m.Set(types.NewString("photosets"), p.NomsValue()))
}
// PhotosetSet

type PhotosetSet struct {
	s types.Set
}

type PhotosetSetIterCallback (func(p Photoset) (stop bool))

func NewPhotosetSet() PhotosetSet {
	return PhotosetSet{types.NewSet()}
}

func PhotosetSetFromVal(p types.Value) PhotosetSet {
	return PhotosetSet{p.(types.Set)}
}

func (s PhotosetSet) NomsValue() types.Set {
	return s.s
}

func (s PhotosetSet) Equals(p PhotosetSet) bool {
	return s.s.Equals(p.s)
}

func (s PhotosetSet) Ref() ref.Ref {
	return s.s.Ref()
}

func (s PhotosetSet) Empty() bool {
	return s.s.Empty()
}

func (s PhotosetSet) Len() uint64 {
	return s.s.Len()
}

func (s PhotosetSet) Has(p Photoset) bool {
	return s.s.Has(p.NomsValue())
}

func (s PhotosetSet) Iter(cb PhotosetSetIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(PhotosetFromVal(v))
	})
}

func (s PhotosetSet) Insert(p ...Photoset) PhotosetSet {
	return PhotosetSet{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s PhotosetSet) Remove(p ...Photoset) PhotosetSet {
	return PhotosetSet{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s PhotosetSet) Union(others ...PhotosetSet) PhotosetSet {
	return PhotosetSet{s.s.Union(s.fromStructSlice(others)...)}
}

func (s PhotosetSet) Subtract(others ...PhotosetSet) PhotosetSet {
	return PhotosetSet{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s PhotosetSet) Any() Photoset {
	return PhotosetFromVal(s.s.Any())
}

func (s PhotosetSet) fromStructSlice(p []PhotosetSet) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s PhotosetSet) fromElemSlice(p []Photoset) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// Photoset

type Photoset struct {
	m types.Map
}

func NewPhotoset() Photoset {
	return Photoset{types.NewMap()}
}

func PhotosetFromVal(v types.Value) Photoset {
	return Photoset{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Photoset) NomsValue() types.Map {
	return s.m
}

func (s Photoset) Equals(p Photoset) bool {
	return s.m.Equals(p.m)
}

func (s Photoset) Ref() ref.Ref {
	return s.m.Ref()
}
func (s Photoset) Title() types.String {
	return s.m.Get(types.NewString("title")).(types.String)
}

func (s Photoset) SetTitle(p types.String) Photoset {
	return PhotosetFromVal(s.m.Set(types.NewString("title"), p))
}
func (s Photoset) Id() types.String {
	return s.m.Get(types.NewString("id")).(types.String)
}

func (s Photoset) SetId(p types.String) Photoset {
	return PhotosetFromVal(s.m.Set(types.NewString("id"), p))
}
func (s Photoset) Photos() PhotoSet {
	return PhotoSetFromVal(s.m.Get(types.NewString("photos")))
}

func (s Photoset) SetPhotos(p PhotoSet) Photoset {
	return PhotosetFromVal(s.m.Set(types.NewString("photos"), p.NomsValue()))
}
// PhotoSet

type PhotoSet struct {
	s types.Set
}

type PhotoSetIterCallback (func(p Photo) (stop bool))

func NewPhotoSet() PhotoSet {
	return PhotoSet{types.NewSet()}
}

func PhotoSetFromVal(p types.Value) PhotoSet {
	return PhotoSet{p.(types.Set)}
}

func (s PhotoSet) NomsValue() types.Set {
	return s.s
}

func (s PhotoSet) Equals(p PhotoSet) bool {
	return s.s.Equals(p.s)
}

func (s PhotoSet) Ref() ref.Ref {
	return s.s.Ref()
}

func (s PhotoSet) Empty() bool {
	return s.s.Empty()
}

func (s PhotoSet) Len() uint64 {
	return s.s.Len()
}

func (s PhotoSet) Has(p Photo) bool {
	return s.s.Has(p.NomsValue())
}

func (s PhotoSet) Iter(cb PhotoSetIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(PhotoFromVal(v))
	})
}

func (s PhotoSet) Insert(p ...Photo) PhotoSet {
	return PhotoSet{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s PhotoSet) Remove(p ...Photo) PhotoSet {
	return PhotoSet{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s PhotoSet) Union(others ...PhotoSet) PhotoSet {
	return PhotoSet{s.s.Union(s.fromStructSlice(others)...)}
}

func (s PhotoSet) Subtract(others ...PhotoSet) PhotoSet {
	return PhotoSet{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s PhotoSet) Any() Photo {
	return PhotoFromVal(s.s.Any())
}

func (s PhotoSet) fromStructSlice(p []PhotoSet) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s PhotoSet) fromElemSlice(p []Photo) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// Photo

type Photo struct {
	m types.Map
}

func NewPhoto() Photo {
	return Photo{types.NewMap()}
}

func PhotoFromVal(v types.Value) Photo {
	return Photo{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Photo) NomsValue() types.Map {
	return s.m
}

func (s Photo) Equals(p Photo) bool {
	return s.m.Equals(p.m)
}

func (s Photo) Ref() ref.Ref {
	return s.m.Ref()
}
func (s Photo) Title() types.String {
	return s.m.Get(types.NewString("title")).(types.String)
}

func (s Photo) SetTitle(p types.String) Photo {
	return PhotoFromVal(s.m.Set(types.NewString("title"), p))
}
func (s Photo) Id() types.String {
	return s.m.Get(types.NewString("id")).(types.String)
}

func (s Photo) SetId(p types.String) Photo {
	return PhotoFromVal(s.m.Set(types.NewString("id"), p))
}
func (s Photo) Image() types.Blob {
	return s.m.Get(types.NewString("image")).(types.Blob)
}

func (s Photo) SetImage(p types.Blob) Photo {
	return PhotoFromVal(s.m.Set(types.NewString("image"), p))
}
func (s Photo) Url() types.String {
	return s.m.Get(types.NewString("url")).(types.String)
}

func (s Photo) SetUrl(p types.String) Photo {
	return PhotoFromVal(s.m.Set(types.NewString("url"), p))
}
