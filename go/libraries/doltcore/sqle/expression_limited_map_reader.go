// Copyright 2020 Liquidata, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sqle

import (
	"context"
	"strings"

	"github.com/src-d/go-mysql-server/sql"
	"github.com/src-d/go-mysql-server/sql/expression"

	"github.com/liquidata-inc/dolt/go/libraries/doltcore/schema"
	"github.com/liquidata-inc/dolt/go/libraries/doltcore/sqle/expreval"
	"github.com/liquidata-inc/dolt/go/libraries/doltcore/sqle/setalgebra"
	"github.com/liquidata-inc/dolt/go/libraries/doltcore/table"
	"github.com/liquidata-inc/dolt/go/libraries/doltcore/table/typed/noms"
	"github.com/liquidata-inc/dolt/go/store/types"
)

var eqOp = expreval.EqualsOp{}

func setForEqOp(nbf *types.NomsBinFormat, val types.Value) (setalgebra.Set, error) {
	return setalgebra.NewFiniteSet(nbf, val)
}

var gtOp = expreval.GreaterOp{}

func setForGtOp(nbf *types.NomsBinFormat, val types.Value) (setalgebra.Set, error) {
	return setalgebra.NewInterval(nbf, &setalgebra.IntervalEndpoint{Val: val, Inclusive: false}, nil), nil
}

var gteOp = expreval.GreaterEqualOp{}

func setForGteOp(nbf *types.NomsBinFormat, val types.Value) (setalgebra.Set, error) {
	return setalgebra.NewInterval(nbf, &setalgebra.IntervalEndpoint{Val: val, Inclusive: true}, nil), nil
}

var ltOp = expreval.LessOp{}

func setForLtOp(nbf *types.NomsBinFormat, val types.Value) (setalgebra.Set, error) {
	return setalgebra.NewInterval(nbf, nil, &setalgebra.IntervalEndpoint{Val: val, Inclusive: false}), nil
}

var lteOp = expreval.LessEqualOp{}

func setForLteOp(nbf *types.NomsBinFormat, val types.Value) (setalgebra.Set, error) {
	return setalgebra.NewInterval(nbf, nil, &setalgebra.IntervalEndpoint{Val: val, Inclusive: true}), nil
}

// getSetForKeyColumn takes a filter, and a single key column (schemas with multiple columns used as keys is not
// supported yet), and returns a set which represents all the values which satisfies the filter for the given key
// column
func getSetForKeyColumn(nbf *types.NomsBinFormat, col schema.Column, filter sql.Expression) (setalgebra.Set, error) {
	switch typedExpr := filter.(type) {
	case *expression.Or:
		return getOrSet(nbf, col, typedExpr.Left, typedExpr.Right)
	case *expression.And:
		return getAndSet(nbf, col, typedExpr.Left, typedExpr.Right)
	case *expression.Equals:
		return setForComparisonExp(nbf, col, typedExpr.BinaryExpression, eqOp, setForEqOp)
	case *expression.GreaterThan:
		gtOp.NBF = nbf
		return setForComparisonExp(nbf, col, typedExpr.BinaryExpression, gtOp, setForGtOp)
	case *expression.GreaterThanOrEqual:
		gteOp.NBF = nbf
		return setForComparisonExp(nbf, col, typedExpr.BinaryExpression, gteOp, setForGteOp)
	case *expression.LessThan:
		ltOp.NBF = nbf
		return setForComparisonExp(nbf, col, typedExpr.BinaryExpression, ltOp, setForLtOp)
	case *expression.LessThanOrEqual:
		lteOp.NBF = nbf
		return setForComparisonExp(nbf, col, typedExpr.BinaryExpression, lteOp, setForLteOp)
		// case *expression.In:
		// case *expression.Subquery:
	}

	return setalgebra.UniversalSet{}, nil
}

// getOrSet gets the set of values which satisfies the or condition.  This will be the union of
// the sets generated by the left and right sides of he or expression.
func getOrSet(nbf *types.NomsBinFormat, col schema.Column, left, right sql.Expression) (setalgebra.Set, error) {
	leftSet, err := getSetForKeyColumn(nbf, col, left)

	if err != nil {
		return nil, err
	}

	rightSet, err := getSetForKeyColumn(nbf, col, right)

	if err != nil {
		return nil, err
	}

	return leftSet.Union(rightSet)
}

// getAndSet gets the set of values which satisfies the and condition.  This will be the intersection of
// the sets generated by the left and right sides of he or expression.
func getAndSet(nbf *types.NomsBinFormat, col schema.Column, left, right sql.Expression) (setalgebra.Set, error) {
	leftSet, err := getSetForKeyColumn(nbf, col, left)

	if err != nil {
		return nil, err
	}

	rightSet, err := getSetForKeyColumn(nbf, col, right)

	if err != nil {
		return nil, err
	}

	return leftSet.Intersect(rightSet)
}

// setForComparisonExp returns the set of values which satisfies the comparison expression for the specified column.
func setForComparisonExp(
	nbf *types.NomsBinFormat,
	col schema.Column,
	be expression.BinaryExpression,
	op expreval.CompareOp,
	createSet func(nbf *types.NomsBinFormat, val types.Value) (setalgebra.Set, error)) (setalgebra.Set, error) {

	variables, literals, compType, err := expreval.GetComparisonType(be)

	if err != nil {
		return nil, err
	}

	switch compType {
	case expreval.ConstConstCompare:
		res, err := op.CompareLiterals(literals[0], literals[1])

		if err != nil {
			return nil, err
		}

		// Comparing literals will have the same result for all columns.  When true it does not limit
		// the range of keys and the universal set is returned.  If it is false then no value can
		// satisfy the condition and the empty set is returned.
		if res {
			return setalgebra.UniversalSet{}, nil
		} else {
			return setalgebra.EmptySet{}, nil
		}

	case expreval.VariableConstCompare:
		// check to see if this comparison is with the primary key column
		if strings.EqualFold(variables[0].Name(), col.Name) {
			val, err := expreval.LiteralToNomsValue(col.Kind, literals[0])

			if err != nil {
				return nil, err
			}

			// create the set for the keys matching the condition
			return createSet(nbf, val)
		} else {
			// not the primary key column, so this will not limit the set of key values, so the universal set is returned.
			return setalgebra.UniversalSet{}, nil
		}

	case expreval.VariableVariableCompare:
		// In the case where one columns value is being compared to another we cannot limit the keys we look at.
		// We need to read the entire row in before filtering.
		return setalgebra.UniversalSet{}, nil
	}

	panic("Unexpected case value")
}

type CreateReaderFunc func(ctx context.Context, m types.Map) (table.TableReadCloser, error)

func CreateReaderFuncLimitedByExpressions(nbf *types.NomsBinFormat, tblSch schema.Schema, filters []sql.Expression) (CreateReaderFunc, error) {
	pkCols := tblSch.GetPKCols()
	if pkCols.Size() == 1 {
		var keySet setalgebra.Set = setalgebra.UniversalSet{}
		var err error
		for _, filter := range filters {
			var setForFilter setalgebra.Set
			setForFilter, err = getSetForKeyColumn(nbf, pkCols.GetByIndex(0), filter)

			if err != nil {
				break
			}

			keySet, err = keySet.Intersect(setForFilter)

			if err != nil {
				break
			}
		}

		if err != nil {
			// should probably log this to some debug logger. don't fail, just fall back on a full table
			// scan.
		} else {
			return getCreateFuncForKeySet(nbf, keySet, tblSch)
		}
	}

	return func(ctx context.Context, m types.Map) (table.TableReadCloser, error) {
		return noms.NewNomsMapReader(ctx, m, tblSch)
	}, nil
}

func finiteSetToKeySlice(nbf *types.NomsBinFormat, tag types.Uint, fs setalgebra.FiniteSet) ([]types.Tuple, error) {
	keys := make([]types.Tuple, len(fs.HashToVal))

	i := 0
	var err error
	for _, v := range fs.HashToVal {
		keys[i], err = types.NewTuple(nbf, tag, v)
		i++

		if err != nil {
			return nil, err
		}
	}

	return keys, nil
}

func rangeForInterval(nbf *types.NomsBinFormat, tag types.Uint, in setalgebra.Interval) (*noms.ReadRange, error) {
	var inclusive bool
	var startVal types.Value
	var reverse bool
	var check noms.InRangeCheck

	if in.Start != nil {
		startVal = in.Start.Val
		inclusive = in.Start.Inclusive

		if in.End == nil {
			check = func(t types.Tuple) (b bool, err error) {
				return true, nil
			}
		} else if in.End.Inclusive {
			check = func(t types.Tuple) (b bool, err error) {
				keyVal, err := t.Get(1)

				if err != nil {
					return false, err
				}

				eq := keyVal.Equals(in.End.Val)

				if eq {
					return true, nil
				}

				return keyVal.Less(nbf, in.End.Val)
			}
		} else {
			check = func(t types.Tuple) (b bool, err error) {
				keyVal, err := t.Get(1)

				if err != nil {
					return false, err
				}

				return keyVal.Less(nbf, in.End.Val)
			}
		}
	} else {
		startVal = in.End.Val
		inclusive = in.End.Inclusive
		reverse = true

		check = func(tuple types.Tuple) (b bool, err error) {
			return true, nil
		}
	}

	startKey, err := types.NewTuple(nbf, tag, startVal)

	if err != nil {
		return nil, err
	}

	return &noms.ReadRange{Start: startKey, Inclusive: inclusive, Reverse: reverse, Check: check}, nil
}

func getCreateFuncForKeySet(nbf *types.NomsBinFormat, keySet setalgebra.Set, sch schema.Schema) (CreateReaderFunc, error) {
	pkCols := sch.GetPKCols()

	if pkCols.Size() != 1 {
		panic("not implemented yet")
	}

	col := pkCols.GetByIndex(0)

	switch typedSet := keySet.(type) {
	case setalgebra.EmptySet:
		return func(ctx context.Context, m types.Map) (reader table.TableReadCloser, err error) {
			return noms.NewNomsMapReaderForKeys(m, sch, []types.Tuple{}), nil
		}, nil

	case setalgebra.FiniteSet:
		return func(ctx context.Context, m types.Map) (reader table.TableReadCloser, err error) {
			keys, err := finiteSetToKeySlice(m.Format(), types.Uint(col.Tag), typedSet)

			if err != nil {
				return nil, err
			}

			return noms.NewNomsMapReaderForKeys(m, sch, keys), nil
		}, nil

	case setalgebra.Interval:
		return func(ctx context.Context, m types.Map) (reader table.TableReadCloser, err error) {
			r, err := rangeForInterval(m.Format(), types.Uint(col.Tag), typedSet)

			if err != nil {
				return nil, err
			}

			return noms.NewNomsRangeReader(sch, m, []*noms.ReadRange{r}), nil
		}, nil

	case setalgebra.CompositeSet:
		var ranges []*noms.ReadRange
		for _, interval := range typedSet.Intervals {
			r, err := rangeForInterval(nbf, types.Uint(col.Tag), interval)

			if err != nil {
				return nil, err
			}

			ranges = append(ranges, r)
		}

		return func(ctx context.Context, m types.Map) (reader table.TableReadCloser, err error) {
			var readers = []table.TableReadCloser{noms.NewNomsRangeReader(sch, m, ranges)}

			if len(typedSet.Set.HashToVal) > 0 {
				keys, err := finiteSetToKeySlice(nbf, types.Uint(col.Tag), typedSet.Set)

				if err != nil {
					return nil, err
				}

				rd := noms.NewNomsMapReaderForKeys(m, sch, keys)
				readers = append(readers, rd)
			}

			return table.NewCompositeTableReader(readers)
		}, nil

	default:
		return func(ctx context.Context, m types.Map) (reader table.TableReadCloser, err error) {
			return noms.NewNomsMapReader(ctx, m, sch)
		}, nil
	}
}
