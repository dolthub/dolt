{{$typesPackage := .TypesPackage}}

// {{.Name}}

type {{.Name}} uint32

{{$name := .Name}}
const ({{range $index, $id := .Ids}}
	{{title $id}}{{if eq $index 0}} {{$name}} = iota{{end}}{{end}}
)

func New{{.Name}}() {{.Name}} {
	return {{.Name}}(0)
}

var __typeRefFor{{.Name}} {{$typesPackage}}TypeRef

func (e {{.Name}}) TypeRef() {{$typesPackage}}TypeRef {
	return __typeRefFor{{.Name}}
}

func init() {
	__typeRefFor{{.Name}} = {{$typesPackage}}MakeTypeRef(__{{.PackageName}}PackageInFile_{{.FileID}}_CachedRef, {{.Ordinal}})
	{{$typesPackage}}RegisterFromValFunction(__typeRefFor{{.Name}}, func(v {{$typesPackage}}Value) {{$typesPackage}}Value {
		return {{.Name}}(uint32(v.({{$typesPackage}}UInt32)))
	})
}

func (e {{.Name}}) InternalImplementation() uint32 {
	return uint32(e)
}

func (e {{.Name}}) Equals(other {{$typesPackage}}Value) bool {
	return e == other
}

func (e {{.Name}}) Ref() ref.Ref {
	throwaway := ref.Ref{}
	return {{$typesPackage}}EnsureRef(&throwaway, e)
}

func (e {{.Name}}) Chunks() []ref.Ref {
	return nil
}
