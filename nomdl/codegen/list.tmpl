{{$typesPackage := .TypesPackage}}

// {{.Name}}

type {{.Name}} struct {
	l   {{$typesPackage}}List
	ref *ref.Ref
}

func New{{.Name}}() {{.Name}} {
	return {{.Name}}{ {{$typesPackage}}NewList(), &ref.Ref{}}
}

{{if .CanUseDef}}
	type {{.Name}}Def []{{defType .ElemType}}

	func (def {{.Name}}Def) New() {{.Name}} {
		l := make([]{{$typesPackage}}Value, len(def))
		for i, d := range def {
			l[i] = {{defToValue "d" .ElemType }}
		}
		return {{.Name}}{ {{$typesPackage}}NewList(l...), &ref.Ref{}}
	}

	func (l {{.Name}}) Def() {{.Name}}Def {
		d := make([]{{defType .ElemType}}, l.Len())
		for i := uint64(0); i < l.Len(); i++ {
			d[i] = {{valueToDef "l.l.Get(i)" .ElemType }}
		}
		return d
	}
{{end}}

func {{.Name}}FromVal(val {{$typesPackage}}Value) {{.Name}} {
	// TODO: Do we still need FromVal?
	if val, ok := val.({{.Name}}); ok {
		return val
	}
	// TODO: Validate here
	return {{.Name}}{val.({{$typesPackage}}List), &ref.Ref{}}
}

func (l {{.Name}}) InternalImplementation() {{$typesPackage}}List {
	return l.l
}

func (l {{.Name}}) Equals(other {{$typesPackage}}Value) bool {
	if other, ok := other.({{.Name}}); ok {
		return l.Ref() == other.Ref()
	}
	return false
}

func (l {{.Name}}) Ref() ref.Ref {
	return {{$typesPackage}}EnsureRef(l.ref, l)
}

func (l {{.Name}}) Chunks() (futures []{{$typesPackage}}Future) {
	futures = append(futures, l.TypeRef().Chunks()...)
	futures = append(futures, l.l.Chunks()...)
	return
}

{{template "type_ref.tmpl" .}}

func (l {{.Name}}) Len() uint64 {
	return l.l.Len()
}

func (l {{.Name}}) Empty() bool {
	return l.Len() == uint64(0)
}

func (l {{.Name}}) Get(i uint64) {{userType .ElemType}} {
	return {{valueToUser "l.l.Get(i)" .ElemType}}
}

func (l {{.Name}}) Slice(idx uint64, end uint64) {{.Name}} {
	return {{.Name}}{l.l.Slice(idx, end), &ref.Ref{}}
}

func (l {{.Name}}) Set(i uint64, val {{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Set(i, {{userToValue "val" .ElemType}}), &ref.Ref{}}
}

func (l {{.Name}}) Append(v ...{{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Append(l.fromElemSlice(v)...), &ref.Ref{}}
}

func (l {{.Name}}) Insert(idx uint64, v ...{{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Insert(idx, l.fromElemSlice(v)...), &ref.Ref{}}
}

func (l {{.Name}}) Remove(idx uint64, end uint64) {{.Name}} {
	return {{.Name}}{l.l.Remove(idx, end), &ref.Ref{}}
}

func (l {{.Name}}) RemoveAt(idx uint64) {{.Name}} {
	return {{.Name}}{(l.l.RemoveAt(idx)), &ref.Ref{}}
}

func (l {{.Name}}) fromElemSlice(p []{{userType .ElemType}}) []{{$typesPackage}}Value {
	r := make([]{{$typesPackage}}Value, len(p))
	for i, v := range p {
		r[i] = {{userToValue "v" .ElemType}}
	}
	return r
}

type {{.Name}}IterCallback func(v {{userType .ElemType}}, i uint64) (stop bool)

func (l {{.Name}}) Iter(cb {{.Name}}IterCallback) {
	l.l.Iter(func(v {{$typesPackage}}Value, i uint64) bool {
		return cb({{valueToUser "v" .ElemType}}, i)
	})
}

type {{.Name}}IterAllCallback func(v {{userType .ElemType}}, i uint64)

func (l {{.Name}}) IterAll(cb {{.Name}}IterAllCallback) {
	l.l.IterAll(func(v {{$typesPackage}}Value, i uint64) {
		cb({{valueToUser "v" .ElemType}}, i)
	})
}

type {{.Name}}FilterCallback func(v {{userType .ElemType}}, i uint64) (keep bool)

func (l {{.Name}}) Filter(cb {{.Name}}FilterCallback) {{.Name}} {
	nl := New{{.Name}}()
	l.IterAll(func(v {{userType .ElemType}}, i uint64) {
		if cb(v, i) {
			nl = nl.Append(v)
		}
	})
	return nl
}
